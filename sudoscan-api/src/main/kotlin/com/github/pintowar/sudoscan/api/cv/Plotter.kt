package com.github.pintowar.sudoscan.api.cv

import com.github.pintowar.sudoscan.api.Digit
import com.github.pintowar.sudoscan.api.ImageMatrix
import com.github.pintowar.sudoscan.api.Puzzle
import mu.KLogging
import java.awt.Color
import kotlin.math.ceil

object Plotter : KLogging() {

    /**
     * Use a frontal image of a sudoku puzzle + a given solution to plot a solution. The generated solution is an image
     * with the number plotted only on empty cells.
     *
     * @param image the frontal image of a sudoku puzzle.
     * @param solution a given puzzle solution.
     * @param solutionColor the color of the solution digits to be plotted.
     * @param recognizedColor the color of the recognized digits to be plotted.
     */
    fun plotSolution(
        image: FrontalPerspective<ImageMatrix>,
        solution: Puzzle,
        solutionColor: Color = Color.GREEN,
        recognizedColor: Color = Color.RED
    ): ImageMatrix {
        val base = image.img
        val squareImage = ImageMatrix.empty(Area(base.width(), base.height()), false)

        val factor = base.width() / 9
        val fSize = base.height() / 350.0

        val solColor = solutionColor.let {
            Color((255 - it.red), (255 - it.green), (255 - it.blue), (255 - it.alpha))
        }
        val predictedColor = recognizedColor.let {
            Color((255 - it.red), (255 - it.green), (255 - it.blue), (255 - it.alpha))
        }

        (0 until solution.gridSize).forEach { i ->
            (0 until solution.gridSize).forEach { j ->
                val textX = ceil(factor * j + factor / 2.0 - 15).toInt()
                val textY = ceil(factor * i + factor / 2.0 + factor / 3.0).toInt()
                val color = if (solution[i, j] is Digit.Found) solColor else predictedColor
                val digit = if (solution[i, j] is Digit.Found) "Found" else "Valid"

                logger.debug { "$digit(${solution[i, j].value}) ($i, $j) : $textX | $textY" }
//                putText(squareImage, "${solution[i, j].value}", Point(textX, textY), font, fSize, color)
                squareImage.putText(solution[i, j], Coordinate(textX, textY), fSize, color)
            }
        }

        return squareImage
    }

    /**
     * This function changes the perspective of the result generated by [plotSolution] (a solution based on the frontal
     * view of the puzzle) to the same angle (perspective) of the original image.
     *
     * @param frontal cropped image of the original image, containing the view of a frontal solution.
     * @param sudokuResult the image with the solution generated by [plotSolution].
     * @param original the original image area.
     */
    fun changePerspectiveToOriginalSize(
        frontal: FrontalPerspective<ImageMatrix>,
        sudokuResult: ImageMatrix,
        originalArea: Area
    ): ImageMatrix {
        val m = frontal.dst.getPerspectiveTransform(frontal.src)
        val img = sudokuResult.warpPerspective(m, originalArea)
        return img.revertColors()
    }

    /**
     * Plot the solution on the original perspective (generated by [changePerspectiveToOriginalSize]) and merge it with
     * the original image.
     *
     * @param original the original and not pre-processed image.
     * @param solution the solution image on the original perspective.
     * @return the final solution plotted on the original image.
     */
    fun combineSolutionToOriginal(original: ImageMatrix, solution: ImageMatrix): ImageMatrix =
        solution.bitwiseAnd(original)
}